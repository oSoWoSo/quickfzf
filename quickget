#!/usr/bin/env bash
export LC_ALL=C

# In order to add an operating system to quickget, add a plugin in the
#   quickget-resources directory

function cleanup() {
  if [ -n "$(jobs -p)" ]; then
    kill "$(jobs -p)"
  fi
}

function format_arch() {
    # Format the architecture in a more standard way (e.g. x86_64 -> amd64)
    case "${1}" in
        x86_64)
            echo "amd64";;
        i386|i686)
            echo "i386";;
        armv8*|aarch64*)
            echo "arm64";;
        riscv*)
            echo "riscv64";;
        *)
            echo "${OUTPUT}";;
    esac
}

function handle_urls() {
    # Handle multiple URLs if necessary
    local DIR="${1}"
    
    if shift && [ -n "${1}" ]; then
        if [ "${TEST_ISO_URL}" != 'true' ] && [ "${DOWNLOAD_ONLY}" != 'true' ]; then
            echo "Downloading ${PRETTY_NAME} ${RELEASE} ${EDITION}"
        fi

        while (( "${#}" )); do
            echo running web_get URL: "${1}" DIR: "${DIR}"
            web_get "${1}" "${DIR}"
            shift
        done
    fi
}

function web_get() {
    local DIR="${2}"
    local FILE="${URL##*/}"
    local URL="${1}"

	if [ "${TEST_ISO_URL}" == 'true' ]; then
        wget --spider "${URL}"
    elif [ "${DOWNLOAD_ONLY}" ]; then
        DIR="$(pwd)"
    fi
    
    if command -v aria2c &>/dev/null; then
        if ! aria2c --stderr -x16 --continue=true --summary-interval=0 --download-result=hide --console-log-level=error "${URL}" --dir "${DIR}" -o "${FILE}"; then
          echo #Necessary as aria2c in suppressed mode does not have new lines
          echo "ERROR! Failed to download ${URL} with aria2c. Try running 'quickget' again."
          exit 1
        fi
        echo #Necessary as aria2c in suppressed mode does not have new lines
    elif command -v wget2 &>/dev/null; then
        if ! wget2 --quiet --continue --tries=3 --read-timeout=10 --force-progress --progress=bar:force:noscroll "${URL}" -O "${DIR}/${FILE}"; then
            echo "ERROR! Failed to download ${URL} with wget2. Try running 'quickget' again."
            exit 1
        fi
    elif ! wget --quiet --continue --tries=3 --read-timeout=10 --show-progress --progress=bar:force:noscroll "${URL}" -O "${DIR}/${FILE}"; then
        echo "ERROR! Failed to download ${URL} with wget. Try running 'quickget' again."
        exit 1
    fi
}

function verify_release() {
    "${PLUGIN}" --validate-re "${ARCH}" "${RELEASE}" "${EDITION}"
    case "${?}" in
        0)
            VM_PATH="${OS}-${RELEASE}-${EDITION}";;
        1)
            exit 1;;
        2)
            VM_PATH="${OS}-${RELEASE}";;
    esac
}

function find_plugin() {
    PLUGIN="${RESOURCE_DIR}/${OS}.os"
    PRETTY_NAME="$("${PLUGIN}" --pretty-name)"
}

function show_iso_url() {
    "${PLUGIN}" --list-urls --friendly
    exit 0
}

function usage() {
    exit 1
}

trap cleanup EXIT

if [ "${UID}" -eq 0 ]; then
    echo "ERROR! Quickget cannot be run as root."
    exit 1
fi

# Create directory to cache release/edition information in the case that it's sourced from the internet.
# OS Template will handle the creation of individual files
if ! mkdir -p "${HOME}/.cache/quickemu"; then
    echo "ERROR! Failed to create cache directory at ${HOME}/.cache/quickemu"
    exit 1
fi

BASE_DIR="$(dirname "${0}")"
VALID_OS=()
for OS_PLUGIN in "${RESOURCE_DIR}"/*.os; do
    VALID_OS+=("$(basename "${OS_PLUGIN}" .os)")
done
PARAMS=()
ARCH="$(uname -m)"

# Set directory which contains quickget resources. If existing in directory with quickget, use that (for those using quickget from git). 
if [ -d "${BASE_DIR}/quickget-resources" ]; then
    RESOURCE_DIR="${BASE_DIR}/quickget-resources"
else
    RESOURCE_DIR="/usr/share/quickemu/quickget-resources"
fi

while (( "${#}" )); do
    case "${1}" in
        list|list_csv)
            list_csv
            exit 0
            ;;
        list_json)
            list_json
            exit 0
            ;;
        --version|-version)
            "${BASE_DIR}"/quickemu ---version
            exit 0
            ;;
        --arch|--architecture)
            ARCH="${2}"
            ;;
        --download-iso)
            DOWNLOAD_ONLY=true
            ;;
        --test-iso-url|-t)
            TEST_ISO_URL=true
            ;;
        --show-iso-url|-s)
            SHOW_ISO_URL=true
            ;;
        --open-distro-homepage|-o)
            OPEN_HOMEPAGE=true
            ;;
        --refresh)
            REFRESH=true
            ;;
        --refresh-all)
            REFRESH_ALL=true
            ;;
        --*|-*)
            echo "Unsupported flag ${1}"
            ;;
        *)
            PARAMS+=("${1}")
            ;;
    esac
    shift
done

ARCH="$(format_arch "${ARCH}")"

OS="${PARAMS[0],,}"
RELEASE="${PARAMS[1]}"
EDITION="${PARAMS[2]}"
if [ "${PARAMS[3]}" ]; then
    echo "Error. Invalid parameters."
    exit 1
fi
export ARCH OS RELEASE EDITION


if [ -n "${OS}" ]; then
    find_plugin
else
    echo "ERROR! You must specify an operating system."
    echo -n " - Operating Systems: "
    echo "${VALID_OS[@]}"
    usage
fi

if [ "${OPEN_HOMEPAGE}" == 'true' ]; then
    URL="$("${PLUGIN}" --homepage)"
    xdg-open "${URL}" || sensible-browser "${URL}" || x-www-browser "${URL}" || gnome-open "${URL}";
    exit 0
elif [ "${REFRESH}" == 'true' ]; then
    "${PLUGIN}" --refresh
elif [ "${REFRESH_ALL}" == 'true' ]; then
    # TODO: Implement a progress indicator. This function may take a while to run.
    # Also use pretty_name to show the current OS being refreshed.
    for OS in "${VALID_OS[@]}"; do
        find_plugin
        "${PLUGIN}" --refresh
    done
    exit 0
fi

# shellcheck disable=SC2076
# This must be in quotes, we're trying to determine if the full string is in the array. i.e. "ubu" must fail if "ubuntu" is the value in the array.
if [[ ! " ${VALID_OS[*]} " =~ " ${OS} " ]]; then
    echo -e "ERROR! ${OS} is not a supported OS.\n"
    echo "${VALID_OS[@]}"
    exit 1
fi

verify_release

# Determine the architecture of the OS given by the plugin. 
FINALARCH="$("${PLUGIN}" --return-arch)"

if [ "${SHOW_ISO_URL}" == 'true' ]; then
    show_iso_url
fi

# Export variables to make accessible within plugin.
VM_DIR="$(pwd)"
export VM_DIR VM_PATH


handle_urls "${VM_PATH}" "$("${PLUGIN}" --list-urls --download "${ARCH}" "${RELEASE}" "${EDITION}")"

# vim:tabstop=4:shiftwidth=4:expandtab
