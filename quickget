#!/usr/bin/env bash
export LC_ALL=C

# In order to add an operating system to quickget, add a plugin in the
#   quickget-resources directory

function cleanup() {
  if [ -n "$(jobs -p)" ]; then
    kill "$(jobs -p)"
  fi
}

# source ui messages. Linked to default messages.en_US.
# shellcheck source=quickget-resources/messages
. ./quickget-resources/messages

function format_arch() {
    # Format the architecture in a more standard way (e.g. x86_64 -> amd64)
    case "${1}" in
        x86_64)
            echo "amd64";;
        i386|i686)
            echo "i386";;
        armv8*|aarch64*)
            echo "arm64";;
        riscv*)
            echo "riscv64";;
        *)
            echo "${OUTPUT}";;
    esac
}

function handle_urls() {
    # Handle multiple URLs if necessary
    if [ "${TEST_ISO_URL}" != 'true' ] && [ "${DOWNLOAD_ONLY}" != 'true' ]; then
        printf '%s %s %s %s' "$MSG_DOWNLOADING" "${PRETTY_NAME}" "${RELEASE}" "${EDITION}"
    fi

    local URL=""
    for URL in ${PLUGIN_OUTPUT}; do
        check_hash "${URL}" || web_get "${URL}" || FILE="${URL}"
    done
}

function check_hash() {
    local HASH="${1}"
    local HASH_ALGO=""

    # Determine the hash algorithm
    case "${#HASH}" in
        32) HASH_ALGO=md5sum;;
        40) HASH_ALGO=sha1sum;;
        64) HASH_ALGO=sha256sum;;
        128) HASH_ALGO=sha512sum;;
        *) return 1;;
    esac

    # If the "hash" contains a forward slash, it must be a URL. 
    if echo "${HASH}" | grep -q "/" || [ -z "${LAST_DOWNLOADED}" ]; then
        return 1
    fi

    printf '%s %s %s %s...' "${MSG_CHECKING_HASH}" "${LAST_DOWNLOADED}" "${MSG_CHECKING_HASH2}" "${HASH_ALGO}"
    if ! echo "${HASH} ${LAST_DOWNLOADED}" | ${HASH_ALGO} --check --status; then
        echo "${MSG_ERROR}"
        echo "${LAST_DOWNLOADED} ${MSG_HASH_NOT_MATCH} ${HASH_ALGO}. ${MSG_HASH_NOT_MATCH2}"
        exit 1
    else
        echo "${MSG_HASH_MATCH}"
    fi

    # --download-iso should only need to download one file. 
    if [ "${DOWNLOAD_ONLY}" == 'true' ]; then
        exit 0
    fi
}

function web_get() {
    local URL="${1}"
    if [ -z "${FILE}" ]; then
        FILE="${URL##*/}"
    fi

    if ! echo "${URL}" | grep -q "/"; then
        return 1
    fi

	if [ "${TEST_ISO_URL}" == 'true' ]; then
        wget --spider "${URL}"
    fi

    if [ "${VM_PATH}" != "$(pwd)" ] && ! mkdir -p "${VM_PATH}" 2>/dev/null; then
      echo "${MSG_ERROR_CANT_CREATE_DIR} ${VM_PATH}"
      exit 1
    fi
    
    if command -v aria2c &>/dev/null; then
        if ! aria2c --stderr -x16 --continue=true --summary-interval=0 --download-result=hide --console-log-level=error "${URL}" --dir "${VM_PATH}" -o "${FILE}"; then
          echo #Necessary as aria2c in suppressed mode does not have new lines
          echo "${MSG_ERROR_DOWNLOAD_ARIA}"
          exit 1
        fi
        echo #Necessary as aria2c in suppressed mode does not have new lines
    elif command -v wget2 &>/dev/null; then
        if ! wget2 --quiet --continue --tries=3 --read-timeout=10 --force-progress --progress=bar:force:noscroll "${URL}" -O "${VM_PATH}/${FILE}"; then
            echo "${MSG_ERROR_DOWNLOAD_WGET2}"
            exit 1
        fi
    elif ! wget --quiet --continue --tries=3 --read-timeout=10 --show-progress --progress=bar:force:noscroll "${URL}" -O "${VM_PATH}/${FILE}"; then
        echo "${MSG_ERROR_DOWNLOAD_WGET}"
        exit 1
    fi

    if [ -z "${IMAGE_FILE}" ]; then
        IMAGE_FILE="${FILE}"
    fi
    # Set the last downloaded filename for use in the check_hash function
    LAST_DOWNLOADED="${VM_PATH}/${FILE}"
    FILE=""
}

function list_json() {
  list_csv | jq -R 'split(",") as $h|reduce inputs as $in ([]; . += [$in|split(",")|. as $a|reduce range(0,length) as $i ({};.[$h[$i]]=$a[$i])])'
}

function list_csv() {
    echo "Display Name,OS,Release,Option,Downloader,PNG,SVG"
    for OS in "${VALID_OS[@]}"; do
        find_plugin
        export OS
        "${PLUGIN}" --csv-urls
    done
}

function verify_release() {
    "${PLUGIN}" --validate-re "${ARCH}" "${RELEASE}" "${EDITION}"
    case "${?}" in
        0)
            VM_PATH="${OS}-${RELEASE}-${EDITION}";;
        1)
            exit 1;;
        2)
            VM_PATH="${OS}-${RELEASE}";;
    esac

    # Set VM path to current directory if --download-iso is used.
    if [ "${DOWNLOAD_ONLY}" == 'true' ]; then
        VM_PATH="$(pwd)"
    fi
}

function handle_config_additions() {
    local CONFIG_ADDITIONS=""
    CONFIG_ADDITIONS="$("${PLUGIN}" --config-additions)"
    echo "${CONFIG_ADDITIONS}" | while IFS= read -r CHANGE; do
        echo "${CHANGE}" >> "${CONF_FILE}"
        echo "${MSG_CONFIG_ADDITION} ${CHANGE}"
    done
}

function make_vm_config() {
    CONF_FILE="${VM_PATH}.conf"
    local IMAGE_TYPE=""
    local GUEST=""

    GUEST="$("${PLUGIN}" --guest)"
    IMAGE_TYPE="$("${PLUGIN}" --image-type)"

    if [ ! -e "${CONF_FILE}" ]; then
        echo "${MSG_MAKING_CONFIG} ${CONF_FILE}"
        cat << EOF > "${CONF_FILE}"
#!$(which quickemu) --vm
guest_os="${GUEST}"
disk_img="${VM_PATH}/disk.qcow2"
${IMAGE_TYPE}="${VM_PATH}/${IMAGE_FILE}"
disk_size="32G"
arch="${FINALARCH}"
EOF
    echo "${MSG_PERMISSIONS} ${CONF_FILE},"
    chmod u+x "${CONF_FILE}"
    fi
    handle_config_additions
}

function find_plugin() {
    PLUGIN="${RESOURCE_DIR}/${OS}.os"
    PRETTY_NAME="$("${PLUGIN}" --pretty-name)" 2>/dev/null
}

function show_iso_url() {
    "${PLUGIN}" --list-urls --friendly
    exit 0
}

function usage() {
    echo -e "${MSG_USAGE}"
    exit 0
}

function usage_help() {
    echo "${MSG_PRINTF_HELP}" "$(quickemu --version)" "$(qemu-x86_64 -version | head -1 | cut -d' ' -f3)"
    echo "${VALID_OS[@]}"
    exit 0
}

trap cleanup EXIT

if [ "${UID}" -eq 0 ]; then
    echo "${MSG_ERROR_NO_ROOT}"
    exit 1
fi

# Create directory to cache release/edition information in the case that it's sourced from the internet.
# OS Template will handle the creation of individual files
if ! mkdir -p "${HOME}/.cache/quickemu"; then
    printf '%s at %s' "${MSG_ERROR_CREATE_CACHE}" "${HOME}"
    exit 1
fi

BASE_DIR="$(dirname "${0}")"
# Set directory which contains quickget resources. If existing in directory with quickget, use that (for those using quickget from git, or development). 
if [ -d "${BASE_DIR}/quickget-resources" ]; then
    RESOURCE_DIR="${BASE_DIR}/quickget-resources"
else
    RESOURCE_DIR="/usr/share/quickemu/quickget-resources"
fi

for OS_PLUGIN in "${RESOURCE_DIR}"/*.os; do
    VALID_OS+=("$(basename "${OS_PLUGIN}" .os)")
done
PARAMS=()
ARCH="$(uname -m)"

while (( "${#}" )); do
    case "${1}" in
        list|list_csv)
            list_csv
            exit 0
            ;;
        list_json)
            list_json
            exit 0
            ;;
        -h|--help)
            usage_help
            #exit 0
            ;;
        -v|--version)
            "${BASE_DIR}"/quickemu ---version
            exit 0
            ;;
        -a|--architecture)
            ARCH="${2}"
            shift
            ;;
        -d|--download-iso)
            # Set as a global variable, in case the plugin uses its own method of downloading.
            export DOWNLOAD_ONLY=true
            ;;
        -t|--test-iso-url)
            TEST_ISO_URL=true
            ;;
        -s|--show-iso-url)
            SHOW_ISO_URL=true
            ;;
        -o|--open-distro-homepage)
            OPEN_HOMEPAGE=true
            ;;
        --refresh)
            REFRESH=true
            ;;
        --refresh-all)
            REFRESH_ALL=true
            ;;
        --*|-*)
            echo "${MSG_ERROR_FLAG}"
            ;;
        *)
            PARAMS+=("${1}")
            ;;
    esac
    shift
done

ARCH="$(format_arch "${ARCH}")"

OS="${PARAMS[0],,}"
RELEASE="${PARAMS[1]}"
EDITION="${PARAMS[2]}"
if [ "${PARAMS[3]}" ]; then
    echo "${MSG_ERROR_INVALID_PARAMETERS}"
    exit 1
fi
export ARCH OS RELEASE EDITION


if [ -n "${OS}" ]; then
    find_plugin
else
    echo "${MSG_ERROR_OS}"
    echo -n "${MSG_OS}"
    echo "${VALID_OS[@]}"
    usage
fi

if [ "${OPEN_HOMEPAGE}" == 'true' ]; then
    URL="$("${PLUGIN}" --homepage)"
    xdg-open "${URL}" || sensible-browser "${URL}" || x-www-browser "${URL}" || gnome-open "${URL}";
    exit 0
elif [ "${REFRESH}" == 'true' ]; then
    "${PLUGIN}" --refresh
elif [ "${REFRESH_ALL}" == 'true' ]; then
    # TODO: Implement a progress indicator. This function may take a while to run.
    # Also use pretty_name to show the current OS being refreshed.
    for OS in "${VALID_OS[@]}"; do
        find_plugin
        "${PLUGIN}" --refresh
    done
    exit 0
fi

# shellcheck disable=SC2076
# This must be in quotes, we're trying to determine if the full string is in the array. i.e. "ubu" must fail if "ubuntu" is the value in the array.
if [[ ! " ${VALID_OS[*]} " =~ " ${OS} " ]]; then
    echo -e "${MSG_ERROR} ${OS} ${MSG_ERROR_OS_SUPPORTED}"
    echo "${VALID_OS[@]}"
    exit 1
fi
verify_release

# Determine the architecture of the OS given by the plugin. 
FINALARCH="$("${PLUGIN}" --return-arch)"

if [ "${SHOW_ISO_URL}" == 'true' ]; then
    show_iso_url
fi

# Export variables to make accessible within plugin.
VM_DIR="$(pwd)"
export VM_DIR VM_PATH

PLUGIN_OUTPUT="$("${PLUGIN}" --list-urls --download)"

case "${?}" in
    0)
        handle_urls
        if [ -z "${LAST_DOWNLOADED}" ]; then
            echo "${MSG_ERROR_NO_URL} ${PRETTY_NAME} ${MSG_ERROR_NO_URL2}"
            exit 1
        fi;;
    1)
        echo "${PLUGIN_OUTPUT}"
        exit 1;;
esac

prepare_image_output="$("${PLUGIN}" --prepare-image)"
if echo "${prepare_image_output}" | grep -q "NEW_IMAGE_FILE"; then
    IMAGE_FILE="${prepare_image_output#*NEW_IMAGE_FILE }"
fi 

make_vm_config

echo -e "${MSG_TO_START} ${PRETTY_NAME} ${MSG_TO_START2}\n ${MSG_TO_START3} ${CONF_FILE}"

