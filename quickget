#!/usr/bin/env bash
export LC_ALL=C

# In order to add an operating system to quickget, add a plugin in the
#   quickget-resources directory

function cleanup() {
  if [ -n "$(jobs -p)" ]; then
    kill "$(jobs -p)"
  fi
}

function format_arch() {
    # Format the architecture in a more standard way (e.g. x86_64 -> amd64)
    case "${1}" in
        x86_64)
            echo "amd64";;
        i386|i686)
            echo "i386";;
        armv8*|aarch64*)
            echo "arm64";;
        riscv*)
            echo "riscv64";;
        *)
            echo "${OUTPUT}";;
    esac
}

function handle_urls() {
    # Handle multiple URLs if necessary
    if [ "${TEST_ISO_URL}" != 'true' ] && [ "${DOWNLOAD_ONLY}" != 'true' ]; then
        echo "Downloading ${PRETTY_NAME} ${RELEASE} ${EDITION}"
    fi

    local URL=""
    for URL in "${URLs[@]}"; do
        check_hash "${URL}" || web_get "${URL}"
    done
}

function check_hash() {
    local FILE=""
    local HASH="${1}"
    local HASH_ALGO=""

    # Determine the hash algorithm
    case "${#HASH}" in
        32) HASH_ALGO=md5sum;;
        40) HASH_ALGO=sha1sum;;
        64) HASH_ALGO=sha256sum;;
        128) HASH_ALGO=sha512sum;;
        *) return 1;;
    esac

    # If the "hash" contains a forward slash, it must be a URL. 
    if echo "${HASH}" | grep -q "/" || [ -z "${LAST_DOWNLOADED}" ]; then
        return 1
    fi

    echo -n "Checking ${LAST_DOWNLOADED} with ${HASH_ALGO}... "
    if ! echo "${HASH} ${LAST_DOWNLOADED}" | ${HASH_ALGO} --check --status; then
        echo "ERROR!"
        echo "${LAST_DOWNLOADED} doesn't match ${HASH}. Try running 'quickget' again."
        exit 1
    else
        echo "Good!"
    fi

    # --download-iso should only need to download one file. 
    if [ "${DOWNLOAD_ONLY}" == 'true' ]; then
        exit 0
    fi
}

function web_get() {
    local FILE="${URL##*/}"
    local URL="${1}"

	if [ "${TEST_ISO_URL}" == 'true' ]; then
        wget --spider "${URL}"
    fi

    if [ "${VM_PATH}" != "$(pwd)" ] && ! mkdir -p "${VM_PATH}" 2>/dev/null; then
      echo "ERROR! Unable to create directory ${VM_PATH}"
      exit 1
    fi
    
    if command -v aria2c &>/dev/null; then
        if ! aria2c --stderr -x16 --continue=true --summary-interval=0 --download-result=hide --console-log-level=error "${URL}" --dir "${VM_PATH}" -o "${FILE}"; then
          echo #Necessary as aria2c in suppressed mode does not have new lines
          echo "ERROR! Failed to download ${URL} with aria2c. Try running 'quickget' again."
          exit 1
        fi
        echo #Necessary as aria2c in suppressed mode does not have new lines
    elif command -v wget2 &>/dev/null; then
        if ! wget2 --quiet --continue --tries=3 --read-timeout=10 --force-progress --progress=bar:force:noscroll "${URL}" -O "${VM_PATH}/${FILE}"; then
            echo "ERROR! Failed to download ${URL} with wget2. Try running 'quickget' again."
            exit 1
        fi
    elif ! wget --quiet --continue --tries=3 --read-timeout=10 --show-progress --progress=bar:force:noscroll "${URL}" -O "${VM_PATH}/${FILE}"; then
        echo "ERROR! Failed to download ${URL} with wget. Try running 'quickget' again."
        exit 1
    fi

    if [ -z "${IMAGE_FILE}" ]; then
        IMAGE_FILE="${FILE}"
    fi
    # Set the last downloaded filename for use in the check_hash function
    LAST_DOWNLOADED="${VM_PATH}/${FILE}"
}

function list_json() {
  list_csv | jq -R 'split(",") as $h|reduce inputs as $in ([]; . += [$in|split(",")|. as $a|reduce range(0,length) as $i ({};.[$h[$i]]=$a[$i])])'
}

function list_csv() {
    echo "Display Name,OS,Release,Option,Downloader,PNG,SVG"
    for OS in "${VALID_OS[@]}"; do
        find_plugin
        export OS
        "${PLUGIN}" --csv-urls
    done
}

function verify_release() {
    "${PLUGIN}" --validate-re "${ARCH}" "${RELEASE}" "${EDITION}"
    case "${?}" in
        0)
            VM_PATH="${OS}-${RELEASE}-${EDITION}";;
        1)
            exit 1;;
        2)
            VM_PATH="${OS}-${RELEASE}";;
    esac

    # Set VM path to current directory if --download-iso is used.
    if [ "${DOWNLOAD_ONLY}" == 'true' ]; then
        VM_PATH="$(pwd)"
    fi
}

function make_vm_config() {
    CONF_FILE="${VM_PATH}.conf"
    local IMAGE_TYPE=""
    local GUEST=""

    GUEST="$("${PLUGIN}" --guest)"
    IMAGE_TYPE="$("${PLUGIN}" --image-type)"

    if [ ! -e "${CONF_FILE}" ]; then
        echo "Making ${CONF_FILE}"
        cat << EOF > "${CONF_FILE}"
#!$(which quickemu) --vm
guest_os="${GUEST}"
disk_img="${VM_PATH}/disk.qcow2"
${IMAGE_TYPE}="${VM_PATH}/${IMAGE_FILE}"
disk_size="32G"
arch="${FINALARCH}"
EOF
    echo "Giving user execute permissions on ${CONF_FILE},"
    chmod u+x "${CONF_FILE}"
    fi
}

function find_plugin() {
    PLUGIN="${RESOURCE_DIR}/${OS}.os"
    PRETTY_NAME="$("${PLUGIN}" --pretty-name)"
}

function show_iso_url() {
    "${PLUGIN}" --list-urls --friendly
    exit 0
}

function usage() {
    exit 1
}

trap cleanup EXIT

if [ "${UID}" -eq 0 ]; then
    echo "ERROR! Quickget cannot be run as root."
    exit 1
fi

# Create directory to cache release/edition information in the case that it's sourced from the internet.
# OS Template will handle the creation of individual files
if ! mkdir -p "${HOME}/.cache/quickemu"; then
    echo "ERROR! Failed to create cache directory at ${HOME}/.cache/quickemu"
    exit 1
fi

BASE_DIR="$(dirname "${0}")"
# Set directory which contains quickget resources. If existing in directory with quickget, use that (for those using quickget from git, or development). 
if [ -d "${BASE_DIR}/quickget-resources" ]; then
    RESOURCE_DIR="${BASE_DIR}/quickget-resources"
else
    RESOURCE_DIR="/usr/share/quickemu/quickget-resources"
fi

for OS_PLUGIN in "${RESOURCE_DIR}"/*.os; do
    VALID_OS+=("$(basename "${OS_PLUGIN}" .os)")
done
PARAMS=()
ARCH="$(uname -m)"

while (( "${#}" )); do
    case "${1}" in
        list|list_csv)
            list_csv
            exit 0
            ;;
        list_json)
            list_json
            exit 0
            ;;
        --version|-version)
            "${BASE_DIR}"/quickemu ---version
            exit 0
            ;;
        --arch|--architecture)
            ARCH="${2}"
            shift
            ;;
        --download-iso)
            # Set as a global variable, in case the plugin uses its own method of downloading.
            export DOWNLOAD_ONLY=true
            ;;
        --test-iso-url|-t)
            TEST_ISO_URL=true
            ;;
        --show-iso-url|-s)
            SHOW_ISO_URL=true
            ;;
        --open-distro-homepage|-o)
            OPEN_HOMEPAGE=true
            ;;
        --refresh)
            REFRESH=true
            ;;
        --refresh-all)
            REFRESH_ALL=true
            ;;
        --*|-*)
            echo "Unsupported flag ${1}"
            ;;
        *)
            PARAMS+=("${1}")
            ;;
    esac
    shift
done

ARCH="$(format_arch "${ARCH}")"

OS="${PARAMS[0],,}"
RELEASE="${PARAMS[1]}"
EDITION="${PARAMS[2]}"
if [ "${PARAMS[3]}" ]; then
    echo "Error. Invalid parameters."
    exit 1
fi
export ARCH OS RELEASE EDITION


if [ -n "${OS}" ]; then
    find_plugin
else
    echo "ERROR! You must specify an operating system."
    echo -n " - Operating Systems: "
    echo "${VALID_OS[@]}"
    usage
fi

if [ "${OPEN_HOMEPAGE}" == 'true' ]; then
    URL="$("${PLUGIN}" --homepage)"
    xdg-open "${URL}" || sensible-browser "${URL}" || x-www-browser "${URL}" || gnome-open "${URL}";
    exit 0
elif [ "${REFRESH}" == 'true' ]; then
    "${PLUGIN}" --refresh
elif [ "${REFRESH_ALL}" == 'true' ]; then
    # TODO: Implement a progress indicator. This function may take a while to run.
    # Also use pretty_name to show the current OS being refreshed.
    for OS in "${VALID_OS[@]}"; do
        find_plugin
        "${PLUGIN}" --refresh
    done
    exit 0
fi

# shellcheck disable=SC2076
# This must be in quotes, we're trying to determine if the full string is in the array. i.e. "ubu" must fail if "ubuntu" is the value in the array.
if [[ ! " ${VALID_OS[*]} " =~ " ${OS} " ]]; then
    echo -e "ERROR! ${OS} is not a supported OS.\n"
    echo "${VALID_OS[@]}"
    exit 1
fi
verify_release

# Determine the architecture of the OS given by the plugin. 
FINALARCH="$("${PLUGIN}" --return-arch)"

if [ "${SHOW_ISO_URL}" == 'true' ]; then
    show_iso_url
fi

# Export variables to make accessible within plugin.
VM_DIR="$(pwd)"
export VM_DIR VM_PATH

URLs=($("${PLUGIN}" --list-urls --download))

if [ "${?}" != 2 ]; then
    handle_urls
fi

make_vm_config

echo -e "\nTo start your ${PRETTY_NAME} virtual machine run:\n    quickemu --vm ${CONF_FILE}\n"

# vim:tabstop=4:shiftwidth=4:expandtab
