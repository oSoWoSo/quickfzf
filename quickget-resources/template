#!/usr/bin/env bash

RESOURCE_DIR="$(dirname "${0}")"

# Instructions: 
# 1. Set mandatory variables below, and set recommended variables if possible
# 2. Modify fetch_info function to include all of the necessary information (or way to fetch it)
# 3. Modify list_urls function to provide ISO(s) for the operating system
# 4. Check out the optional variables below the list_urls function to see if you have a use for any of them
# 5. If necessary, modify config_additions and/or prepare_image functions if you need it for your OS.

# MANDATORY VARIABLES: You must set these to appropriate values for your OS.

# Homepage of the operating system (URL)
readonly HOMEPAGE=""
# Set this to 1 if your fetch_info function fetches data from the internet, 0 if it's hardcoded
readonly CACHE_DATA=0
# Set this variable depending on whether or not the operating system requires an edition to be specified
readonly REQUIRES_EDITION=0
# Add all valid architectures for your operating system here. The first one in the array will be the default (if host system does not match)
# Use the most standard name for each architecture. Example: amd64, arm64, riscv64, i386. NOT: x86_64, aarch64, x86, riscv.
readonly ARCHITECTURES=(amd64)

# (OPTIONAL, HIGHLY RECOMMENDED) Brief description of the operating system
readonly DESCRIPTION=""
# (OPTIONAL, HIGHLY RECOMMENDED) Set this to the friendly name of the operating system, if applicable. 
readonly PRETTY_NAME="${OS}"


function fetch_info() {
    case "${ARCH}" in
        amd64)
            # Add editions and releases here. Or, replace this with your code to fetch releases and editions.
            RELEASES+=()
            # You may leave EDITIONS blank if there is only one edition.
            EDITIONS+=()

            # If unique editions are required per release, use this template.
            # You may still put static editions (those which are present for ALL releases) in the EDITIONS array 
            # associativeEDITIONS['RELEASE1']="EDITION1;EDITION2;EDITION3"
            # associativeEDITIONS['RELEASE2']="EDITION1;EDITION2;EDITION3";;
            ;;

        # Add other architectures here if necessary, like this.
        # arm64)
            # RELEASES+=()
            # EDITIONS+=();;
    esac
}

function list_urls() {
    fetch_from_cache

    # Here, you can insert the URL, ISO, and HASH, similarly to the original quickget.
    # Alternatively, you may replace it with anything else, or call another function you create if necessary.
    local URL=""
    local ISO=""
    local HASH=""

    # You can also use switch cases to handle the variables differently depending on architecture or anything else

    # These are default options. You may change them if necessary. If multiple files need to be downloaded,
    # they may be separated by a space, with hashes (if applicable) following the applicable files (once again, separated by a space).
    # Of course, each HASH or URL should be enclosed in double quotes.
    # If you need to handle ALL downloading within this function, call whatever method you'd like, and then uncomment 'exit 2' so quickget knows to skip download.
    case "${2}" in
        # Friendly is the show_iso_url option. It should print the URL(s) in a way that's easily readable, and not hashes
        --friendly)
            echo "${URL}/${ISO}";;
        # The first file (if multiple are present) will be listed as the ISO in the VM config. 
        --download)
            echo "${URL}/${ISO}" "${HASH}";;
    esac
    # exit 2
}

# OPTIONAL VARIABLES. Use these to customize the behavior if necessary

# Set this to 1 if the operating system has unique editions (which you will set) for each release, 0 otherwise
readonly UNIQUE_EDITIONS=0
# If an edition is NOT required but multiple editions ARE available, put the default edition's name here.
readonly DEFAULT_EDITION=""
# If the operating system has a unique name for its editions (i.e. Windows: Languages), set it here
readonly EDITION_NAME="Editions"
# Set this to the OS type. These allow quickemu to optimize for your OS.
# Do not modify unless you know what is supported in this option or if you're adding it to quickemu
readonly GUEST_TYPE="linux"
# Set this to the image type (iso/img)
readonly IMAGE_TYPE="iso"
# Set this to the amount of days before the cache is considered outdated and refreshed (if fetching from internet)
readonly CACHE_DAYS=7


# OPTIONAL. Only use these functions if you need to do something special with the VM config or image file
function config_additions() {
    # Here, you can add any additional configuation options that should be included in the VM config.
    # Just echo them out (in quotation marks) if you want to append them to the other options.
    # Add "OVERRIDE" before the string to instead replace the value of a default option.
    # Example: echo OVERRIDE "disk_size=\"40G\"" to replace the default disk_size with 40G.
    # You can REMOVE options by adding REMOVE before the option name. 
    # Example: echo REMOVE "disk_size" to remove the disk_size option, such as for macOS VMs which have disk_size handled in quickemu
    exit 0
}

function prepare_image() {
    # If you need to do anything to the image before it's used (for example, uncompressing), do it here.
    # Echo the filename(s) of the old image followed by that of the new image.
    # Example: echo ""
    exit 0
}

# Everything below here should not have to be modified. Variables above are used to determine the proper behavior
# I'm expecting to move most of this to a separate file which will be run with `source`, but it'll remain here until functional
function validate_re() {
    local REL=""
    local ED=""
    fetch_from_cache
    
    if [ -z "${RELEASE}" ]; then
        echo "ERROR! You must specify a release."
        format_re
        exit 1
    fi

    # Check if release is present in the releases array
    for REL in "${RELEASES[@]}"; do
        if [ "${RELEASE,,}" == "${REL,,}" ]; then
            # Handle unnecessary editions passed
            if [ -z "${EDITIONS[*]}" ] && [ -n "${EDITION}" ]; then
                echo "WARNING: ${PRETTY_NAME} does not support ${EDITION_NAME,,}. Ignoring."
                exit 2
            elif [ -z "${EDITION}" ] && [ "${REQUIRES_EDITION}" -eq 0 ]; then
                exit 2
            elif [ -z "${EDITION}" ] && [ "${REQUIRES_EDITION}" -eq 1 ]; then
                echo -en "ERROR: You must specify an edition.\n - ${PRETTY_NAME} ${RELEASE} Editions: "
                list_editions
                exit 1
            fi

            # Handle the associative array for unique editions
            if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
                while read -d ';' -r aEDITION; do
                    EDITIONS+=("${aEDITION}")
                done <<< "${associativeEDITIONS["${RELEASE}"]};"
            fi

            # Loop through editions array and check if the edition is present
            for ED in "${EDITIONS[@]}"; do
                if [ "${EDITION,,}" == "${ED,,}" ]; then
                    exit 0
                fi
            done

            echo -e "ERROR! ${EDITION} is not a supported ${PRETTY_NAME} ${RELEASE} edition.\n"
            list_editions
            exit 1
        fi
    done

    echo "ERROR! ${PRETTY_NAME} ${RELEASE} is not a supported release."
    format_re 
    exit 1
}

function format_re() {
    if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
        echo PLACEHOLDER
    else
        echo " - Releases:" "${RELEASES[@]}"
        if [ -n "${EDITIONS[*]}" ]; then
            echo " - Editions:" "${EDITIONS[@]}"
        fi
    fi
}

function list_editions() {
    # Handle the associative array for unique editions
    local fullEDITIONS=("${EDITIONS[@]}")
    if [ "${UNIQUE_EDITIONS}" -eq 1 ]; then
        while read -d ';' -r aEDITION; do
            fullEDITIONS+=("${aEDITION}")
        done <<< "${associativeEDITIONS["${RELEASE}"]};"
    fi
    echo "${fullEDITIONS[@]}"
}

function fetch_from_cache() {
    local REL=""
    local ED=""
    local tempEDITIONS=()

    if [[ "${CACHE_DATA}" == 0 ]]; then
        fetch_info
        return 0
    fi
    # Determine whether cache file exists and whether it contains up to date data.
    if [ ! -f "${CACHE_FILE}" ] || [[ $(( $(date +%s) - $(head -n 1 < "${CACHE_FILE}") )) -ge $(( CACHE_DAYS * 86400 )) ]]; then
        fetch_info
        populate_cache
        return 0
    fi

    echo RELEASES
    mapfile -t RELEASES < <(jq -r '..|.Release?|strings' "${CACHE_FILE}")
    echo "${RELEASES[@]}"

    if [[ "${UNIQUE_EDITIONS}" -eq 1 ]]; then
        # shellcheck disable=SC1009
        for REL in "${RELEASES[@]}"; do
            mapfile -t tempEDITIONS < <(jq -r '.[] | select(.Release == '\""${REL}"\"') .Editions[]' "${CACHE_FILE}")
            # shellcheck disable=SC1073
            for ED in "${tempEDITIONS[@]}"; do
                associativeEDITIONS["${REL}"]+=";${ED}"
            done
        done
    else
        mapfile -t EDITIONS < <(jq -r '..|.Edition?|select(. != "")' "${CACHE_FILE}")
    fi
}

function populate_cache() {
    # Populate cache with JSON data, to be read by fetch_from_cache function
    local REL=""
    local ED=""
    local fullEDITIONS=()
    local JSON_DATA=()

    if [ -f "${CACHE_FILE}" ]; then
        rm "${CACHE_FILE}"
    fi

    date +%s >> "${CACHE_FILE}"


    for REL in "${RELEASES[@]}"; do
        fullEDITIONS=("$(list_editions)")

        for ED in "${fullEDITIONS[@]}"; do
            JSON_DATA+=("
    {
        \"Release\": \"${REL}\",
        \"Edition\": \"${ED}\"
    }")
        done
    done
    IFS=','; echo -e "[\n${JSON_DATA[*]}\n]" >> "${CACHE_FILE}"
}

function verify_arch() {
    for ARCHITECTURE in "${ARCHITECTURES[@]}"; do
        if [ "${ARCHITECTURE}" == "${ARCH}" ]; then
            return 0
        fi
    done
    ARCH="${ARCHITECTURES[0]}"
}


verify_arch
CACHE_FILE="${HOME}/.cache/quickemu/${OS}-${ARCH}.cache"
declare -A associativeEDITIONS

# Set the edition to the default if necessary
if [ -z "${EDITION}" ] && [ -n "${DEFAULT_EDITION}" ] && [ "${REQUIRES_EDITION}" -eq 0 ]; then
    EDITION="${DEFAULT_EDITION}"
fi

case "${1}" in
    --homepage)
        echo "${HOMEPAGE}";;
    --edition-name)
        echo "${EDITION_NAME}";;
    --pretty-name)
        echo "${PRETTY_NAME}";;
    --return-arch)
        echo "${ARCH}";;
    --description)
        echo "${DESCRIPTION}";;
    --guest)
        echo "${GUEST_TYPE}";;
    --image-type)
        echo "${IMAGE_TYPE}";;
    --refresh)
        if [ "${CACHE_DATA}" -eq 1 ]; then
            fetch_info
            populate_cache
        fi;;
    --validate-re)
        validate_re;;
    --list-urls)
        list_urls "${@}";;
    --prepare-image)
        prepare_image;;
    --config-additions)
        config_additions;;
esac

# vim:tabstop=4:shiftwidth=4:expandtab